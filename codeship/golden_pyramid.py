# coding: utf-8
"""
Нашему Робо-Трио необходимо тренироваться для будущих приключений
  и охоты за сокровищами (золотые контакты нужны всем). Стефан
  построил специальную упрощенную модель пирамиды. И теперь наши
  роботы будут тренироваться в забегах за золотом на скорость.
  Они начинают с вершины пирамиды и собирают золото в каждой
  комнате, через которую проходят. В каждой комнате они выбирают
  влево или вправо и спускаются на следующий уровень. Чтобы
  оценивать результаты, Стефану нужно знать, а сколько максимум
  можно собрать за один забег.

Представьте кортеж (tuple) кортежей в котором первый массив имеет
  одно число и следующие на одно число больше чем предыдущий.
  Такой кортеж кортежей будет выглядеть как треугольник. Вам
  нужно написать функцию, которая поможет Стефану найти
  максимальную сумму золота на самом выгодном маршруте с вершины
  пирамиды до ее основания. Все маршруты прохода по пирамиде из
  шагов вниз и влево/вправо.

Примечание:
Попробуйте думать о шаге вниз-влево, как о движении
  в следующий ряд не изменяя индекс в ряду и о шаге вниз/вправо
  -- с увеличением индекса в ряду на единицу. Будьте осторожны
  если вы хотите решать задачу рекурсией. получится медленное решение.
*********************** ЗАДАНИЕ *******************************
Предусловия:
0 < len(pyramid) ≤ 20
all(all(0 < x < 10 for x in row) for row in pyramid)

Ввод: Пирамида, как кортеж (tuple) кортежей. Каждый кортеж
  содержит целочисленное (int).

Вывод: Максимально количество золота за один забег,
  как целочисленное (int).
"""


def count_gold(pyramid):
    """
    Return max possible sum in a path from top to bottom
    """
    swap_pyramid = reversed(pyramid)
    max_res = []
    for i, row in enumerate(swap_pyramid):
        max_obj = cur = 0
        tmp_max_obj = []
        for j, obj in enumerate(row):
            if max_res:
                pass
            else:
                cur = obj
                if max_obj != 0:
                    if cur > max_obj:
                        max_obj = cur
                        tmp_max_obj = [[max_obj, j]]
                    elif cur == max_obj:
                        tmp_max_obj.append([cur, j])
                else:
                    max_obj = cur
                    tmp_max_obj.append([cur, j])

        max_res.append([i for i in tmp_max_obj])

    return sum(max_res)


if __name__ == '__main__':
    #  These "asserts" using only for self-checking and not necessary for auto-testing
    assert count_gold((
        (1,),
        (2, 3),
        (3, 3, 1),
        (3, 1, 5, 4),
        (3, 1, 3, 1, 3),
        (2, 2, 2, 2, 2, 2),
        (5, 6, 4, 5, 6, 4, 3)
    )) == 23, "First example"
    assert count_gold((
        (1,),
        (2, 1),
        (1, 2, 1),
        (1, 2, 1, 1),
        (1, 2, 1, 1, 1),
        (1, 2, 1, 1, 1, 1),
        (1, 2, 1, 1, 1, 1, 9)
    )) == 15, "Second example"
    assert count_gold((
        (9,),
        (2, 2),
        (3, 3, 3),
        (4, 4, 4, 4)
    )) == 18, "Third example"
